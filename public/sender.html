<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>å±€åŸŸç½‘ WebRTC å¤šæ–‡ä»¶ + æ–‡å­—å…±äº«ï¼ˆå‘é€ç«¯ï¼‰</title>
<style>
  :root {
    --system-blue: #007AFF;
    --system-gray: #8E8E93;
    --system-background: #F2F2F7;
    --system-grouped-background: #FFFFFF;
    --system-separator: #C6C6C8;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Helvetica Neue', sans-serif;
    max-width: 800px;
    margin: 0 auto;
    padding: 0;
    min-height: 100vh;
    background: var(--system-background);
    color: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  h2 {
    margin: 1.5em 0 1em;
    font-size: 1.5em;
    font-weight: 600;
    color: #000;
    text-align: center;
  }

  .card {
    width: 100%;
    max-width: 800px;
    background: var(--system-grouped-background);
    border-radius: 12px;
    margin: 1em 0;
    padding: 1.2em;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  label {
    color: var(--system-gray);
    font-size: 0.9em;
    font-weight: 500;
    margin-bottom: 0.5em;
    display: block;
  }

  input[type="text"] {
    width: 100%;
    padding: 0.8em;
    font-size: 1em;
    border: 1px solid var(--system-separator);
    border-radius: 8px;
    background: var(--system-grouped-background);
    margin-bottom: 1em;
  }

  textarea {
    width: 100%;
    min-height: 120px;
    padding: 0.8em;
    font-size: 1em;
    border: 1px solid var(--system-separator);
    border-radius: 8px;
    background: var(--system-grouped-background);
    margin-bottom: 1em;
    resize: vertical;
  }

  .button-group {
    display: flex;
    gap: 0.5em;
    margin: 0.5em 0;
  }

  button {
    padding: 0.8em 1.5em;
    font-size: 1em;
    border-radius: 8px;
    background: var(--system-blue);
    color: white;
    border: none;
    font-weight: 500;
    cursor: pointer;
    transition: opacity 0.2s;
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  button:hover:not(:disabled) {
    opacity: 0.9;
  }

  .secondary-button {
    background: var(--system-gray);
  }

  #fileInput {
    display: none;
  }

  .file-input-label {
    display: inline-block;
    padding: 0.8em 1.5em;
    background: var(--system-blue);
    color: white;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 500;
  }

  progress {
    width: 100%;
    height: 4px;
    border-radius: 2px;
    background: var(--system-separator);
    margin: 0.5em 0;
  }

  progress::-webkit-progress-bar {
    background: var(--system-separator);
    border-radius: 2px;
  }

  progress::-webkit-progress-value {
    background: var(--system-blue);
    border-radius: 2px;
  }

  #progressText {
    color: var(--system-gray);
    font-size: 0.9em;
  }

  #receiverList {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  #receiverList li {
    padding: 0.8em;
    margin: 0.5em 0;
    background: var(--system-background);
    border-radius: 8px;
    display: flex;
    align-items: center;
    color: #000;
  }

  #receiverList li::before {
    content: "â—";
    color: #34C759;
    margin-right: 0.5em;
    font-size: 1.2em;
  }

  .copy-button {
    padding: 0.4em 0.8em;
    font-size: 0.9em;
    background: var(--system-background);
    color: var(--system-blue);
    border: 1px solid var(--system-blue);
    border-radius: 6px;
    margin-left: auto;
  }

  @media (max-width: 600px) {
    body {
      padding: 0 1em;
    }
    
    .card {
      padding: 1em;
    }

    .button-group {
      flex-direction: column;
    }

    button {
      width: 100%;
    }
  }
</style>
</head>
<body>

<h2>å‘é€ç«¯ - å¤šæ–‡ä»¶ & æ–‡å­—å…±äº«</h2>

<div class="card">
  <label>æˆ¿é—´ID</label>
  <div style="display: flex; gap: 0.5em; align-items: center;">
    <input type="text" id="roomId" readonly />
    <button id="btnCreate">ç”Ÿæˆ</button>
    <button class="copy-button" onclick="copyRoomId()">å¤åˆ¶</button>
  </div>
</div>

<div class="card">
  <label>å·²è¿æ¥çš„æ¥æ”¶ç«¯</label>
  <ul id="receiverList"></ul>
  <p id="noReceivers" style="color: var(--system-gray); text-align: center;">æš‚æ— è¿æ¥çš„æ¥æ”¶ç«¯</p>
</div>

<div class="card">
  <label>å…±äº«æ–‡å­—</label>
  <textarea id="textInput" placeholder="åœ¨è¿™é‡Œè¾“å…¥è¦å…±äº«çš„æ–‡å­—"></textarea>
  <div class="button-group">
    <button id="btnSendText" disabled>å‘é€</button>
    <button class="copy-button" onclick="copyText()">å¤åˆ¶æ–‡å­—</button>
  </div>
</div>

<div class="card">
  <label>å…±äº«æ–‡ä»¶</label>
  <label class="file-input-label" for="fileInput">é€‰æ‹©æ–‡ä»¶</label>
  <input type="file" id="fileInput" multiple />
  <div id="selectedFiles" style="margin: 1em 0;"></div>
  <button id="btnSendFiles" disabled>å‘é€æ–‡ä»¶</button>
</div>

<div class="card">
  <label>ä¼ è¾“è¿›åº¦</label>
  <progress id="progressBar" value="0" max="100"></progress>
  <span id="progressText"></span>
</div>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(() => {
  const wsUrl = location.origin.replace(/^http/, 'ws');
  let ws, pc;
  let dataChannels = new Map();  // key: client id, value: dataChannel
  let roomId = null;
  let clients = new Set();  // ä¿å­˜æ‰€æœ‰æ¥æ”¶ç«¯ID
  const maxChunkSize = 16 * 1024; // 16KB åˆ†ç‰‡å¤§å°
  let myClientId = null;

  // UI Elements
  const roomIdInput = document.getElementById('roomId');
  const btnCreate = document.getElementById('btnCreate');
  const textInput = document.getElementById('textInput');
  const btnSendText = document.getElementById('btnSendText');
  const fileInput = document.getElementById('fileInput');
  const btnSendFiles = document.getElementById('btnSendFiles');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  const receiverList = document.getElementById('receiverList');
  const noReceivers = document.getElementById('noReceivers');
  const selectedFiles = document.getElementById('selectedFiles');

  // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ¢å¤æˆ¿é—´ID
  window.addEventListener('DOMContentLoaded', () => {
    const rid = localStorage.getItem('senderRoomId');
    if (rid) {
      roomId = rid;
      roomIdInput.value = rid;
      initWebSocket();
      updateButtons(false);
    }
  });

  // ç”Ÿæˆéšæœºæˆ¿é—´ID
  function generateRoomId() {
    return Math.random().toString(36).substr(2, 8);
  }

  // åˆå§‹åŒ– WebSocket ä¿¡ä»¤
  function initWebSocket() {
    ws = new WebSocket(wsUrl);
    ws.onopen = () => {
      // ç­‰å¾… welcome æ¶ˆæ¯è·å– clientId
    };
    ws.onmessage = async (evt) => {
      const msg = JSON.parse(evt.data);

      if (msg.type === 'welcome') {
        myClientId = msg.clientId;
        ws.send(JSON.stringify({ type: 'join', room: roomId }));
        log(`WebSocket å·²è¿æ¥ï¼ŒåŠ å…¥æˆ¿é—´ ${roomId}`);
        return;
      }

      if (msg.type === 'new-peer') {
        const clientId = msg.clientId;
        if (dataChannels.has(clientId)) return;
        createPeerConnection(clientId, true);
      }

      if (msg.type === 'offer' && msg.from) {
        createPeerConnection(msg.from, false);
        await peerConnections[msg.from].setRemoteDescription(new RTCSessionDescription(msg.offer));
        const answer = await peerConnections[msg.from].createAnswer();
        await peerConnections[msg.from].setLocalDescription(answer);
        ws.send(JSON.stringify({ type: 'answer', to: msg.from, answer }));
      }

      if (msg.type === 'answer' && msg.from) {
        if (!peerConnections[msg.from]) return;
        await peerConnections[msg.from].setRemoteDescription(new RTCSessionDescription(msg.answer));
      }

      if (msg.type === 'ice-candidate' && msg.from) {
        if (!peerConnections[msg.from]) return;
        try {
          await peerConnections[msg.from].addIceCandidate(msg.candidate);
        } catch (e) {
          console.warn('æ·»åŠ  ICE candidate å¤±è´¥', e);
        }
      }

      if (msg.type === 'sender-left') {
        alert('æœ‰æ¥æ”¶ç«¯æ–­å¼€è¿æ¥');
        updateReceiverList(); // æ›´æ–°æ¥æ”¶ç«¯åˆ—è¡¨
      }
    };
    ws.onclose = () => {
      log('WebSocket è¿æ¥å…³é—­');
      clients.clear(); // æ¸…ç©ºæ‰€æœ‰æ¥æ”¶ç«¯
      dataChannels.clear(); // æ¸…ç©ºæ‰€æœ‰æ•°æ®é€šé“
      updateButtons(false);
      updateReceiverList(); // æ›´æ–°æ¥æ”¶ç«¯åˆ—è¡¨
    };
  }

  // PeerConnection ç®¡ç†
  let peerConnections = {};

  function createPeerConnection(clientId, isInitiator) {
    if (peerConnections[clientId]) return;
    const pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });
    peerConnections[clientId] = pc;

    pc.onicecandidate = ({ candidate }) => {
      if (candidate) {
        ws.send(JSON.stringify({ type: 'ice-candidate', to: clientId, candidate }));
      }
    };

    pc.onconnectionstatechange = () => {
      if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
        log('PeerConnection æ–­å¼€');
        clients.delete(clientId); // ä»æ¥æ”¶ç«¯åˆ—è¡¨ä¸­ç§»é™¤
        dataChannels.delete(clientId); // ä»æ•°æ®é€šé“åˆ—è¡¨ä¸­ç§»é™¤
        if (clients.size === 0) updateButtons(false);
        updateReceiverList(); // æ›´æ–°æ¥æ”¶ç«¯åˆ—è¡¨
      }
    };

    if (isInitiator) {
      const dc = pc.createDataChannel('data');
      setupDataChannel(dc, clientId);
      dataChannels.set(clientId, dc);
      pc.createOffer().then(offer => {
        pc.setLocalDescription(offer);
        ws.send(JSON.stringify({ type: 'offer', to: clientId, offer }));
      });
    } else {
      pc.ondatachannel = (e) => {
        setupDataChannel(e.channel, clientId);
        dataChannels.set(clientId, e.channel);
      };
    }
  }

  // ç›‘å¬ DataChannel äº‹ä»¶
  function setupDataChannel(dc, clientId) {
    dc.binaryType = 'arraybuffer';
    dc.onopen = () => {
      log(`DataChannel ä¸ ${clientId} è¿æ¥æ‰“å¼€`);
      clients.add(clientId);
      updateButtons(true);
      updateReceiverList();
    };
    dc.onclose = () => {
      log(`DataChannel ä¸ ${clientId} å…³é—­`);
      clients.delete(clientId);
      dataChannels.delete(clientId);
      if (clients.size === 0) updateButtons(false);
      updateReceiverList();
    };
    dc.onerror = (e) => {
      console.error('DataChannel é”™è¯¯:', e);
      clients.delete(clientId);
      dataChannels.delete(clientId);
      if (clients.size === 0) updateButtons(false);
      updateReceiverList();
    };

    let receivedBuffers = [];
    let receivedSize = 0;
    let fileMetadata = null;

    dc.onmessage = (event) => {
      const data = event.data;

      // è§£ææ¶ˆæ¯æ ¼å¼ï¼šJSON åŒ…è£¹ä¿¡æ¯æˆ– ArrayBuffer æ–‡ä»¶æ•°æ®
      if (typeof data === 'string') {
        try {
          const msg = JSON.parse(data);

          if (msg.type === 'text') {
            log(`æ¥æ”¶æ–‡å­—ï¼š${msg.text}`);
            alert(`æ¥æ”¶ç«¯æ”¶åˆ°æ–‡å­—ï¼š\n${msg.text}`);
          }

          if (msg.type === 'file-meta') {
            fileMetadata = msg.meta;
            receivedBuffers = [];
            receivedSize = 0;
            log(`å¼€å§‹æ¥æ”¶æ–‡ä»¶ï¼š${fileMetadata.name} å¤§å° ${fileMetadata.size} å­—èŠ‚`);
          }

          if (msg.type === 'file-end') {
            // æ–‡ä»¶æ¥æ”¶å®Œæˆï¼Œåˆå¹¶å¹¶è§¦å‘ä¸‹è½½
            const blob = new Blob(receivedBuffers);
            downloadFile(blob, fileMetadata.name);
            receivedBuffers = [];
            receivedSize = 0;
            fileMetadata = null;
            log('æ–‡ä»¶æ¥æ”¶å®Œæˆ');
          }
        } catch (e) {
          console.error('è§£ææ¶ˆæ¯å¤±è´¥', e);
        }
      } else if (data instanceof ArrayBuffer) {
        receivedBuffers.push(data);
        receivedSize += data.byteLength;
        const percent = fileMetadata ? Math.floor((receivedSize / fileMetadata.size) * 100) : 0;
        progressBar.value = percent;
        progressText.textContent = `ä¸‹è½½è¿›åº¦: ${percent}%`;
      }
    };
  }

  // ä¸‹è½½æ–‡ä»¶è¾…åŠ©å‡½æ•°
  function downloadFile(blob, filename) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // å‘é€æ–‡å­—
  function sendText() {
    const text = textInput.value.trim();
    if (!text) return;
    const msg = JSON.stringify({ type: 'text', text });
    dataChannels.forEach(dc => {
      if (dc.readyState === 'open') dc.send(msg);
    });
    log('æ–‡å­—å·²å‘é€');
    textInput.value = '';
  }

  // å‘é€æ–‡ä»¶ï¼ˆå…ˆ ZIPï¼Œå†åˆ†ç‰‡å‘é€ï¼‰
  async function sendFiles() {
    const files = Array.from(fileInput.files);
    if (files.length === 0) return;

    // ZIP æ‰“åŒ…
    const zip = new JSZip();
    files.forEach(f => zip.file(f.name, f));
    const zippedBlob = await zip.generateAsync({ type: 'blob' });

    const reader = new FileReader();
    reader.onload = () => {
      const arrayBuffer = reader.result;

      // å…ˆå‘é€æ–‡ä»¶å…ƒä¿¡æ¯
      const meta = {
        name: `files_${Date.now()}.zip`,
        size: arrayBuffer.byteLength
      };

      const metaMsg = JSON.stringify({ type: 'file-meta', meta });
      dataChannels.forEach(dc => {
        if (dc.readyState === 'open') dc.send(metaMsg);
      });

      // åˆ†ç‰‡å‘é€æ•°æ®
      const chunkSize = maxChunkSize;
      let offset = 0;

      function sendChunk() {
        if (offset >= arrayBuffer.byteLength) {
          const endMsg = JSON.stringify({ type: 'file-end' });
          dataChannels.forEach(dc => {
            if (dc.readyState === 'open') dc.send(endMsg);
          });
          progressBar.value = 100;
          progressText.textContent = `ä¸Šä¼ å®Œæˆ`;
          return;
        }

        const slice = arrayBuffer.slice(offset, offset + chunkSize);
        dataChannels.forEach(dc => {
          if (dc.readyState === 'open') dc.send(slice);
        });
        offset += chunkSize;
        const percent = Math.floor((offset / arrayBuffer.byteLength) * 100);
        progressBar.value = percent;
        progressText.textContent = `ä¸Šä¼ è¿›åº¦: ${percent}%`;

        setTimeout(sendChunk, 10); // æ§åˆ¶å‘é€èŠ‚å¥ï¼Œé¿å…é˜»å¡
      }

      sendChunk();
    };

    reader.readAsArrayBuffer(zippedBlob);
  }

  // æ—¥å¿—
  function log(msg) {
    console.log('[Sender]', msg);
  }

  // UI æ§åˆ¶æŒ‰é’®å¯ç”¨çŠ¶æ€
  function updateButtons(enabled) {
    btnSendText.disabled = !enabled;
    btnSendFiles.disabled = !enabled;
  }

  btnCreate.onclick = () => {
    roomId = generateRoomId();
    roomIdInput.value = roomId;
    localStorage.setItem('senderRoomId', roomId);
    initWebSocket();
    updateButtons(false);
  };

  btnSendText.onclick = sendText;
  btnSendFiles.onclick = sendFiles;

  // æ›´æ–°æ¥æ”¶ç«¯åˆ—è¡¨æ˜¾ç¤º
  function updateReceiverList() {
    receiverList.innerHTML = '';
    if (clients.size > 0) {
      noReceivers.style.display = 'none';
      clients.forEach(clientId => {
        const li = document.createElement('li');
        li.innerHTML = `
          <span>æ¥æ”¶ç«¯ ${clientId.slice(0, 8)}...</span>
          <button class="copy-button" onclick="copyClientId('${clientId}')">å¤åˆ¶ID</button>
        `;
        receiverList.appendChild(li);
      });
    } else {
      noReceivers.style.display = 'block';
    }
  }

  // å¤åˆ¶æ–‡å­—
  function copyText() {
    const text = document.getElementById('textInput').value;
    if (text) {
      navigator.clipboard.writeText(text).then(() => {
        alert('æ–‡å­—å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
      });
    }
  }

  // å¤åˆ¶å®¢æˆ·ç«¯ID
  function copyClientId(clientId) {
    navigator.clipboard.writeText(clientId).then(() => {
      alert('æ¥æ”¶ç«¯IDå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    });
  }

  // æ–‡ä»¶é€‰æ‹©å¤„ç†
  fileInput.addEventListener('change', () => {
    const files = fileInput.files;
    selectedFiles.innerHTML = '';
    
    if (files.length > 0) {
      btnSendFiles.disabled = false;
      
      // åˆ›å»ºæ–‡ä»¶åˆ—è¡¨
      const fileList = document.createElement('ul');
      fileList.style.cssText = `
        list-style: none;
        padding: 0;
        margin: 0;
      `;
      
      // æ·»åŠ æ¸…ç©ºæŒ‰é’®
      const clearButton = document.createElement('button');
      clearButton.textContent = 'æ¸…ç©ºæ–‡ä»¶åˆ—è¡¨';
      clearButton.style.cssText = `
        margin-bottom: 1em;
        background: var(--system-gray);
      `;
      clearButton.onclick = () => {
        fileInput.value = '';
        selectedFiles.innerHTML = '';
        btnSendFiles.disabled = true;
      };
      selectedFiles.appendChild(clearButton);
      
      Array.from(files).forEach((file, index) => {
        const li = document.createElement('li');
        li.style.cssText = `
          display: flex;
          align-items: center;
          padding: 0.8em;
          margin: 0.5em 0;
          background: var(--system-background);
          border-radius: 8px;
          color: #000;
        `;
        
        // æ–‡ä»¶å›¾æ ‡
        const icon = document.createElement('span');
        icon.textContent = 'ğŸ“„';
        icon.style.marginRight = '0.5em';
        
        // æ–‡ä»¶ä¿¡æ¯
        const info = document.createElement('div');
        info.style.flex = '1';
        
        const name = document.createElement('div');
        name.textContent = file.name;
        name.style.fontWeight = '500';
        
        const size = document.createElement('div');
        size.textContent = formatFileSize(file.size);
        size.style.fontSize = '0.9em';
        size.style.color = 'var(--system-gray)';
        
        info.appendChild(name);
        info.appendChild(size);
        
        // åˆ é™¤æŒ‰é’®
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'åˆ é™¤';
        deleteButton.style.cssText = `
          padding: 0.4em 0.8em;
          font-size: 0.9em;
          background: var(--system-background);
          color: #FF3B30;
          border: 1px solid #FF3B30;
          border-radius: 6px;
          margin-left: 0.5em;
        `;
        deleteButton.onclick = () => {
          const dt = new DataTransfer();
          const files = fileInput.files;
          for (let i = 0; i < files.length; i++) {
            if (i !== index) {
              dt.items.add(files[i]);
            }
          }
          fileInput.files = dt.files;
          if (dt.files.length === 0) {
            btnSendFiles.disabled = true;
          }
          // è§¦å‘ change äº‹ä»¶ä»¥æ›´æ–°æ–‡ä»¶åˆ—è¡¨
          fileInput.dispatchEvent(new Event('change'));
        };
        
        li.appendChild(icon);
        li.appendChild(info);
        li.appendChild(deleteButton);
        fileList.appendChild(li);
      });
      
      selectedFiles.appendChild(fileList);
    } else {
      btnSendFiles.disabled = true;
    }
  });

  // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
  function formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
})();

// å°†å¤åˆ¶åŠŸèƒ½ç§»åˆ°å…¨å±€ä½œç”¨åŸŸ
window.copyText = function() {
  const text = document.getElementById('textInput').value;
  if (text) {
    navigator.clipboard.writeText(text).then(() => {
      alert('æ–‡å­—å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    });
  }
};

window.copyRoomId = function() {
  const roomId = document.getElementById('roomId').value;
  if (roomId) {
    navigator.clipboard.writeText(roomId).then(() => {
      alert('æˆ¿é—´IDå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    });
  }
};

window.copyClientId = function(clientId) {
  navigator.clipboard.writeText(clientId).then(() => {
    alert('æ¥æ”¶ç«¯IDå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
  });
};
</script>

</body>
</html>
