<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>å±€åŸŸç½‘ WebRTC å¤šæ–‡ä»¶ + æ–‡å­—å…±äº«ï¼ˆæ¥æ”¶ç«¯ï¼‰</title>
<style>
  :root {
    --system-blue: #007AFF;
    --system-gray: #8E8E93;
    --system-background: #F2F2F7;
    --system-grouped-background: #FFFFFF;
    --system-separator: #C6C6C8;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Helvetica Neue', sans-serif;
    max-width: 800px;
    margin: 0 auto;
    padding: 0;
    min-height: 100vh;
    background: var(--system-background);
    color: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  h2 {
    margin: 1.5em 0 1em;
    font-size: 1.5em;
    font-weight: 600;
    color: #000;
    text-align: center;
  }

  .card {
    width: 100%;
    max-width: 800px;
    background: var(--system-grouped-background);
    border-radius: 12px;
    margin: 1em 0;
    padding: 1.2em;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  label {
    color: var(--system-gray);
    font-size: 0.9em;
    font-weight: 500;
    margin-bottom: 0.5em;
    display: block;
  }

  input[type="text"] {
    width: 100%;
    padding: 0.8em;
    font-size: 1em;
    border: 1px solid var(--system-separator);
    border-radius: 8px;
    background: var(--system-grouped-background);
    margin-bottom: 1em;
  }

  textarea {
    width: 100%;
    min-height: 120px;
    padding: 0.8em;
    font-size: 1em;
    border: 1px solid var(--system-separator);
    border-radius: 8px;
    background: var(--system-grouped-background);
    margin-bottom: 1em;
    resize: vertical;
  }

  .button-group {
    display: flex;
    gap: 0.5em;
    margin: 0.5em 0;
  }

  button {
    padding: 0.8em 1.5em;
    font-size: 1em;
    border-radius: 8px;
    background: var(--system-blue);
    color: white;
    border: none;
    font-weight: 500;
    cursor: pointer;
    transition: opacity 0.2s;
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  button:hover:not(:disabled) {
    opacity: 0.9;
  }

  progress {
    width: 100%;
    height: 4px;
    border-radius: 2px;
    background: var(--system-separator);
    margin: 0.5em 0;
  }

  progress::-webkit-progress-bar {
    background: var(--system-separator);
    border-radius: 2px;
  }

  progress::-webkit-progress-value {
    background: var(--system-blue);
    border-radius: 2px;
  }

  #progressText {
    color: var(--system-gray);
    font-size: 0.9em;
  }

  #fileList {
    margin: 1em 0;
  }

  .file-item {
    display: flex;
    align-items: center;
    padding: 0.8em;
    margin: 0.5em 0;
    background: var(--system-background);
    border-radius: 8px;
    color: var(--system-blue);
    text-decoration: none;
    font-weight: 500;
    transition: opacity 0.2s;
  }

  .file-item:hover {
    opacity: 0.8;
  }

  .file-item::before {
    content: "ğŸ“„";
    margin-right: 0.5em;
  }

  .copy-button {
    padding: 0.4em 0.8em;
    font-size: 0.9em;
    background: var(--system-background);
    color: var(--system-blue);
    border: 1px solid var(--system-blue);
    border-radius: 6px;
    margin-left: auto;
  }

  @media (max-width: 600px) {
    body {
      padding: 0 1em;
    }
    
    .card {
      padding: 1em;
    }

    .button-group {
      flex-direction: column;
    }

    button {
      width: 100%;
    }
  }
</style>
</head>
<body>

<h2>æ¥æ”¶ç«¯ - å¤šæ–‡ä»¶ & æ–‡å­—å…±äº«</h2>

<div class="card">
  <label>æˆ¿é—´ID</label>
  <div style="display: flex; gap: 0.5em; align-items: center;">
    <input type="text" id="roomIdInput" placeholder="è¾“å…¥å‘é€ç«¯æä¾›çš„æˆ¿é—´ID" />
    <button id="btnJoin">åŠ å…¥</button>
  </div>
</div>

<div class="card">
  <label>æ¥æ”¶çš„æ–‡å­—å†…å®¹</label>
  <textarea id="textOutput" readonly></textarea>
  <button class="copy-button" onclick="copyReceivedText()">å¤åˆ¶æ–‡å­—</button>
</div>

<div class="card">
  <label>æ¥æ”¶çš„æ–‡ä»¶</label>
  <div id="fileList"></div>
</div>

<div class="card">
  <label>ä¸‹è½½è¿›åº¦</label>
  <progress id="progressBar" value="0" max="100"></progress>
  <span id="progressText"></span>
</div>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(() => {
  const wsUrl = location.origin.replace(/^http/, 'ws');
  let ws;
  let pc;
  let dc;

  let roomId = null;
  const maxChunkSize = 16 * 1024;

  const roomIdInput = document.getElementById('roomIdInput');
  const btnJoin = document.getElementById('btnJoin');
  const textOutput = document.getElementById('textOutput');
  const fileList = document.getElementById('fileList');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');

  let receivedBuffers = [];
  let expectedFileSize = 0;
  let receivedSize = 0;

  let myClientId = null;
  let peerConnections = {};
  let dataChannels = {};

  btnJoin.onclick = () => {
    roomId = roomIdInput.value.trim();
    if (!roomId) {
      alert('è¯·è¾“å…¥æˆ¿é—´ID');
      return;
    }
    localStorage.setItem('receiverRoomId', roomId);
    initWebSocket();
  };

  // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ¢å¤æˆ¿é—´ID
  window.addEventListener('DOMContentLoaded', () => {
    const rid = localStorage.getItem('autoJoinRoomId') || localStorage.getItem('receiverRoomId');
    if (rid) {
      roomIdInput.value = rid;
      // ç¡®ä¿åœ¨é¡µé¢å®Œå…¨åŠ è½½åæ‰§è¡ŒåŠ å…¥æ“ä½œ
      setTimeout(() => {
        btnJoin.click();
      }, 100);
    }
  });

  function log(msg) {
    console.log('[Receiver]', msg);
  }

  function initWebSocket() {
    ws = new WebSocket(wsUrl);
    ws.onopen = () => {
      // ç­‰å¾… welcome æ¶ˆæ¯è·å– clientId
    };
    ws.onmessage = async (evt) => {
      const msg = JSON.parse(evt.data);

      if (msg.type === 'welcome') {
        myClientId = msg.clientId;
        ws.send(JSON.stringify({ type: 'join', room: roomId }));
        log(`WebSocket connected, joined room ${roomId}`);
        return;
      }

      if (msg.type === 'new-peer') {
        const clientId = msg.clientId;
        if (peerConnections[clientId]) return;
        createPeerConnection(clientId, false);
      }

      if (msg.type === 'offer' && msg.from) {
        createPeerConnection(msg.from, false);
        await peerConnections[msg.from].setRemoteDescription(new RTCSessionDescription(msg.offer));
        const answer = await peerConnections[msg.from].createAnswer();
        await peerConnections[msg.from].setLocalDescription(answer);
        ws.send(JSON.stringify({ type: 'answer', to: msg.from, answer }));
      }

      if (msg.type === 'answer' && msg.from) {
        if (!peerConnections[msg.from]) return;
        await peerConnections[msg.from].setRemoteDescription(new RTCSessionDescription(msg.answer));
      }

      if (msg.type === 'ice-candidate' && msg.from) {
        if (!peerConnections[msg.from]) return;
        try {
          await peerConnections[msg.from].addIceCandidate(msg.candidate);
        } catch (e) {
          console.warn('Failed to add ICE candidate:', e);
        }
      }

      if (msg.type === 'sender-left') {
        alert('å‘é€ç«¯æ–­å¼€ï¼Œå†…å®¹å·²æ¸…ç©º');
        resetState();
      }
    };
    ws.onclose = () => {
      log('WebSocket closed');
    };
  }

  function createPeerConnection(clientId, isInitiator) {
    if (peerConnections[clientId]) return;
    const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
    peerConnections[clientId] = pc;

    pc.onicecandidate = ({ candidate }) => {
      if (candidate) {
        ws.send(JSON.stringify({ type: 'ice-candidate', to: clientId, candidate }));
      }
    };

    pc.onconnectionstatechange = () => {
      if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
        log('PeerConnection æ–­å¼€');
      }
    };

    pc.ondatachannel = (event) => {
      dataChannels[clientId] = event.channel;
      setupDataChannel(event.channel);
    };
  }

  function setupDataChannel(channel) {
    channel.binaryType = 'arraybuffer';

    channel.onopen = () => {
      log('DataChannel opened');
    };

    channel.onclose = () => {
      log('DataChannel closed');
    };

    channel.onerror = (e) => {
      console.error('DataChannel error:', e);
    };

    channel.onmessage = (event) => {
      if (typeof event.data === 'string') {
        try {
          const msg = JSON.parse(event.data);
          if (msg.type === 'text') {
            textOutput.value = msg.text;
          }
          else if (msg.type === 'file-meta') {
            expectedFileSize = msg.meta.size;
            receivedSize = 0;
            receivedBuffers = [];
            progressBar.value = 0;
            progressText.textContent = '0%';
            log(`å‡†å¤‡æ¥æ”¶æ–‡ä»¶ï¼Œå¤§å°: ${expectedFileSize} bytes`);
          }
        } catch (e) {
          console.error('è§£ææ–‡æœ¬æ¶ˆæ¯å¤±è´¥', e);
        }
      } else {
        // æ¥æ”¶æ–‡ä»¶æ•°æ®åˆ†ç‰‡
        receivedBuffers.push(event.data);
        receivedSize += event.data.byteLength;
        let percent = Math.floor((receivedSize / expectedFileSize) * 100);
        progressBar.value = percent;
        progressText.textContent = percent + '%';

        if (receivedSize >= expectedFileSize) {
          // åˆå¹¶ ArrayBuffer
          const blob = new Blob(receivedBuffers);
          receivedBuffers = [];

          // è§£å‹ ZIP å¹¶æ˜¾ç¤ºæ–‡ä»¶ä¸‹è½½é“¾æ¥
          JSZip.loadAsync(blob).then(zip => {
            updateFileList(zip);
          });

          progressText.textContent = 'æ¥æ”¶å®Œæˆ';
          log('æ–‡ä»¶æ¥æ”¶å®Œæˆ');
        }
      }
    };
  }

  function resetState() {
    textOutput.value = '';
    fileList.innerHTML = '';
    progressBar.value = 0;
    progressText.textContent = '';
    receivedBuffers = [];
    expectedFileSize = 0;
    receivedSize = 0;
    if (pc) {
      pc.close();
      pc = null;
    }
  }

  // å¤åˆ¶æ¥æ”¶åˆ°çš„æ–‡å­—
  window.copyReceivedText = function() {
    const text = document.getElementById('textOutput').value;
    if (text) {
      navigator.clipboard.writeText(text).then(() => {
        // åˆ›å»ºæç¤ºå…ƒç´ 
        const notification = document.createElement('div');
        notification.textContent = 'æ–‡å­—å·²å¤åˆ¶åˆ°å‰ªè´´æ¿';
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 10px 20px;
          border-radius: 8px;
          font-size: 14px;
          z-index: 1000;
          animation: fadeInOut 2s ease-in-out;
        `;
        document.body.appendChild(notification);

        // 2ç§’åç§»é™¤æç¤º
        setTimeout(() => {
          notification.remove();
        }, 2000);
      });
    }
  };

  // æ·»åŠ åŠ¨ç”»æ ·å¼
  const style = document.createElement('style');
  style.textContent = `
    @keyframes fadeInOut {
      0% { opacity: 0; transform: translate(-50%, -20px); }
      15% { opacity: 1; transform: translate(-50%, 0); }
      85% { opacity: 1; transform: translate(-50%, 0); }
      100% { opacity: 0; transform: translate(-50%, -20px); }
    }
  `;
  document.head.appendChild(style);

  // æ›´æ–°æ–‡ä»¶åˆ—è¡¨æ˜¾ç¤º
  function updateFileList(zip) {
    const fileList = document.getElementById('fileList');
    fileList.innerHTML = '';
    zip.forEach((relativePath, file) => {
      file.async('blob').then(blobFile => {
        const url = URL.createObjectURL(blobFile);
        const a = document.createElement('a');
        a.href = url;
        a.download = file.name;
        a.textContent = file.name;
        a.className = 'file-item';
        fileList.appendChild(a);
      });
    });
  }
})();
</script>

</body>
</html>

